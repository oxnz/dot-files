#!/usr/bin/env python3

import re
import sys
import subprocess


def current_branch():
    # figure out which branch we're on
    output = subprocess.check_output(['git', 'symbolic-ref', '--short', 'HEAD']).rstrip()
    return output.decode('utf-8')


def proc(commit_msg_filepath, commit_type, commit_hash):
    # figure out which branch we're on
    branch = current_branch()
    # populate the commit message with the issue #, if there is one
    r = re.fullmatch(r'(?P<category>\w+)-(?P<name>\w+)', branch)
    if branch == 'master':
        raise ValueError('commit directly to master branch is prohibited')
    elif r is None:
        raise ValueError(f'invalid branch name: {branch}')
    category = r['category']
    name = r['name']
    required_message = f'{category.upper()}-{name}'
    print(f'prepare-commit-msg: [{commit_type}]({commit_msg_filepath})')
    with open(commit_msg_filepath, 'r+') as f:
        content = f.read()
        if not content.startswith(required_message):
            f.seek(0, 0)
            f.write(required_message)


if __name__ == '__main__':
    # collect the parameters
    commit_msg_filepath = sys.argv[1]
    argc = len(sys.argv)
    if argc > 2:
        commit_type = sys.argv[2]
    else:
        commit_type = ''
    if argc > 3:
        commit_hash = sys.argv[3]
    else:
        commit_hash = ''
    try:
        proc(commit_msg_filepath, commit_type, commit_hash)
    except Exception as e:
        print(f'prepare-commit-msg: ERROR! {e}')
        sys.exit(1)
